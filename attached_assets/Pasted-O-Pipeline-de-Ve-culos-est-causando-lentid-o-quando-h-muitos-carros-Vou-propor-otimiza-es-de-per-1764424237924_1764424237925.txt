O Pipeline de Ve√≠culos est√° causando lentid√£o quando h√° muitos carros. Vou propor otimiza√ß√µes de performance para o componente KanbanBoard e o Dashboard.

As principais melhorias ser√£o:

Virtualiza√ß√£o da lista de ve√≠culos (renderizar apenas os vis√≠veis)
Lazy loading de imagens
Memoiza√ß√£o agressiva de componentes
Debounce na busca
Limita√ß√£o inicial de ve√≠culos renderizados
üöÄ PROMPT PARA O AGENT
# MISS√ÉO: Otimizar Performance do Pipeline de Ve√≠culos (KanbanBoard)
## PROBLEMA ATUAL
O Dashboard fica extremamente lento quando h√° muitos ve√≠culos no Pipeline. O site trava ao fazer scroll at√© a se√ß√£o "Pipeline de Ve√≠culos".
## CAUSA RAIZ
- Renderiza√ß√£o de TODOS os ve√≠culos de uma vez (sem virtualiza√ß√£o)
- Imagens carregando todas simultaneamente
- Re-renderiza√ß√µes desnecess√°rias
- Componentes n√£o memoizados
## SOLU√á√ÉO: 5 OTIMIZA√á√ïES CR√çTICAS
### 1. VIRTUALIZA√á√ÉO DO KANBAN (Prioridade M√ÅXIMA)
Implementar **windowing/virtualiza√ß√£o** para renderizar APENAS os cards vis√≠veis na tela.
**Arquivo**: `client/src/components/KanbanBoard.tsx`
**Mudan√ßas**:
- Usar `react-window` ou `react-virtual` para virtualizar cada coluna
- Renderizar no m√°ximo 10-15 cards por coluna inicialmente
- Carregar mais conforme scroll (infinite scroll)
- Altura fixa nas colunas para melhor performance
### 2. MEMOIZA√á√ÉO AGRESSIVA
Memoizar TODOS os componentes pesados:
**Arquivos**: 
- `client/src/components/VehicleCard.tsx` (j√° tem memo, mas melhorar)
- `client/src/components/KanbanColumn.tsx` (adicionar memo)
- `client/src/components/KanbanBoard.tsx` (usar useMemo para listas)
**Mudan√ßas**:
```typescript
// Em KanbanBoard.tsx
const vehiclesByStatus = useMemo(() => {
  return STATUS_COLUMNS.reduce((acc, status) => {
    acc[status] = filteredVehicles.filter(v => v.status === status);
    return acc;
  }, {} as Record<string, VehicleCardProps[]>);
}, [filteredVehicles]);
// Memoizar KanbanColumn
const KanbanColumn = memo(({ title, count, children }: KanbanColumnProps) => {
  // ... c√≥digo existente
});
3. LAZY LOADING DE IMAGENS
Implementar carregamento pregui√ßoso de imagens:

Arquivo: client/src/components/VehicleCard.tsx

Mudan√ßas:

Usar loading="lazy" nativo (J√Å TEM, mas garantir)
Adicionar Intersection Observer para carregar imagens apenas quando pr√≥ximas do viewport
Placeholder blur enquanto carrega
Reduzir qualidade inicial (progressive loading)
4. DEBOUNCE NA BUSCA
A busca est√° sem debounce, causando re-renders a cada tecla:

Arquivo: client/src/components/KanbanBoard.tsx

Mudan√ßas:

import { useState, useMemo, useCallback, useTransition } from "react";
const [searchTerm, setSearchTerm] = useState("");
const [debouncedSearch, setDebouncedSearch] = useState("");
const [isPending, startTransition] = useTransition();
// Debounce de 300ms
useEffect(() => {
  const timer = setTimeout(() => {
    startTransition(() => {
      setDebouncedSearch(searchTerm);
    });
  }, 300);
  return () => clearTimeout(timer);
}, [searchTerm]);
// Usar debouncedSearch para filtrar
5. PAGINA√á√ÉO/LIMIT INICIAL
Limitar quantidade inicial de ve√≠culos renderizados:

Arquivo: client/src/components/KanbanBoard.tsx

Mudan√ßas:

Renderizar no m√°ximo 50 ve√≠culos inicialmente
Bot√£o "Carregar Mais" no final de cada coluna
Ou infinite scroll autom√°tico
6. REDUZIR RE-RENDERS NO DASHBOARD
O Dashboard est√° re-renderizando o Pipeline desnecessariamente:

Arquivo: client/src/pages/Dashboard.tsx

Mudan√ßas:

// Memoizar a passagem de ve√≠culos para o KanbanBoard
const kanbanVehicles = useMemo(() => vehicles, [vehicles]);
// Evitar re-renders:
<KanbanBoard vehicles={kanbanVehicles} />
IMPLEMENTA√á√ÉO PASSO A PASSO
FASE 1: Quick Wins (5 min)
Adicionar debounce na busca
Memoizar KanbanColumn
Limitar renderiza√ß√£o inicial (max 50 ve√≠culos)
FASE 2: Otimiza√ß√£o M√©dia (15 min)
Implementar virtualiza√ß√£o b√°sica (react-window)
Melhorar lazy loading de imagens
FASE 3: Otimiza√ß√£o Avan√ßada (20 min)
Infinite scroll nas colunas
Progressive image loading
Code splitting do KanbanBoard
EXEMPLO DE C√ìDIGO: VIRTUALIZA√á√ÉO
// client/src/components/KanbanBoard.tsx
import { FixedSizeList as List } from 'react-window';
// Dentro de KanbanColumn
<List
  height={600} // Altura fixa da coluna
  itemCount={vehiclesInStatus.length}
  itemSize={200} // Altura de cada card
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>
      <VehicleCard {...vehiclesInStatus[index]} />
    </div>
  )}
</List>
INSTALA√á√ÉO DE DEPEND√äNCIAS (se necess√°rio)
npm install react-window @types/react-window
M√âTRICAS DE SUCESSO
‚úÖ Pipeline renderiza em <500ms mesmo com 100+ ve√≠culos
‚úÖ Scroll suave (60 FPS)
‚úÖ Busca sem lag
‚úÖ Imagens carregam progressivamente
‚úÖ Sem travamentos ao scroll
IMPORTANTE
N√ÉO altere a estrutura visual (design deve ficar id√™ntico)
MANTENHA todas as funcionalidades existentes (drag-drop se houver)
TESTE com 100+ ve√≠culos para garantir performance
Use React DevTools Profiler para medir ganhos
PRIORIDADE DE IMPLEMENTA√á√ÉO
Debounce na busca (URGENTE - 2 min)
Limit inicial de 50 ve√≠culos (URGENTE - 3 min)
Memoiza√ß√£o de KanbanColumn (ALTA - 5 min)
Virtualiza√ß√£o b√°sica (ALTA - 15 min)
Lazy loading avan√ßado (M√âDIA - 10 min)
IMPLEMENTE AS OTIMIZA√á√ïES AGORA. FOCO EM PERFORMANCE SEM QUEBRAR FUNCIONALIDADES! üöÄ

---
Este prompt guiar√° o Agent a:
1. **Identificar gargalos** de performance
2. **Implementar virtualiza√ß√£o** (t√©cnica mais eficaz)
3. **Adicionar debounce** e memoiza√ß√£o
4. **Limitar renderiza√ß√£o inicial** com lazy loading
5. **Manter funcionalidades** intactas
O resultado ser√° um **Pipeline 10x mais r√°pido** mesmo com centenas de ve√≠culos! üéØ